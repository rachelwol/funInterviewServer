{
  "questions": [
    {
      "question": "מהו ההבדל בין struct ל-class ב-C#?",
      "options": [
        "struct הוא value type ו-class הוא reference type",
        "אין הבדל משמעותי",
        "struct תמיד מוקצה על ה-heap",
        "class לא יכול לרשת מclass אחר"
      ],
      "correctAnswer": 0,
      "explain": ""
    },
    {
      "question": "מהו delegates ב-C#?",
      "options": [
        "סוג של משתנה",
        "טיפוס המייצג reference למתודה",
        "מחלקה לניהול זיכרון",
        "ממשק להורשה מרובה"
      ],
      "correctAnswer": 1,
      "explain": ""
    },
    {
      "question": "מהו async/await ב-C#?",
      "options": [
        "מנגנון לסנכרון threads",
        "דרך לכתיבת קוד אסינכרוני",
        "שיטה להרצת קוד במקביל",
        "טכניקה לניהול exceptions"
      ],
      "correctAnswer": 1,
      "explain": ""
    },
    {
      "question": "איך את מטפלת בשגיאות?",
      "options": [
        "אני בודקת את הקוד שורה שורה כדי לוודא שאין שגיאות. אם אני מוצאת שגיאה, אני מתקנת אותה ידנית.",
        "אני משתמשת ב-debugger כדי לעבור על הקוד צעד צעד ולמצוא את השגיאות.",
        "ע''י exception handling, שימוש ב try, catch ו finally.<br> try-  הינו בלוק קוד שתוכו צפויה להתרחש שגיאה. catch - הינו בלוק קוד שמתבצע כאשר מתרחשת שגיאה. finally - בלוק קוד שמתבצע תמיד, בין אם מתרחשת שגיאה ובין אם לא.",
        "אני מסתמכת על המסרים שהמחשב מציג לי כשמתרחשת שגיאה."
      ],
      "correctAnswer": 2,
      "explain": ""
    },
    {
      "question": "מהו ההבדל בין ref ל-out ב-C#?",
      "options": [
        "ref דורש אתחול המשתנה לפני השימוש, out לא",
        "אין הבדל ביניהם",
        "out משמש רק למספרים",
        "ref משמש רק למחרוזות"
      ],
      "correctAnswer": 0,
      "explain": "ההבדל העיקרי בין ref ל-out הוא שמשתנה המועבר כ-ref חייב להיות מאותחל לפני העברתו לפונקציה, בעוד שמשתנה המועבר כ-out לא חייב להיות מאותחל. בנוסף, פונקציה המקבלת פרמטר out חייבת לאתחל אותו לפני סיום הפונקציה."
    },
    {
      "question": "מהי מטרת ה-using statement?",
      "options": [
        "ייבוא מרחבי שמות",
        "שחרור משאבים באופן אוטומטי",
        "הגדרת משתנים",
        "יצירת לולאות"
      ],
      "correctAnswer": 1,
      "explain": "ה-using statement מבטיח שחרור נכון של משאבים (כמו קבצים או חיבורי מסד נתונים) על ידי קריאה אוטומטית ל-Dispose בסיום הבלוק. זה חשוב במיוחד כאשר עובדים עם משאבים מנוהלים שמיישמים את הממשק IDisposable."
    },
    {
      "question": "מהו Pattern Matching ב-C#?",
      "options": [
        "מנגנון לבדיקת והמרת טיפוסים",
        "כלי לחיפוש טקסט",
        "שיטה ליצירת אובייקטים",
        "מנגנון להשוואת מחרוזות"
      ],
      "correctAnswer": 0,
      "explain": "Pattern Matching הוא תכונה המאפשרת לבדוק את הטיפוס והערך של אובייקט בו-זמנית. זה מאפשר כתיבת קוד יותר תמציתי וקריא, במיוחד בעבודה עם מבני switch ותנאים מורכבים."
    },
    {
      "question": "מהו Record Type ב-C#?",
      "options": [
        "טיפוס נתונים בלתי משתנה",
        "מחלקה רגילה",
        "סוג של משתנה",
        "מבנה נתונים דינמי"
      ],
      "correctAnswer": 0,
      "explain": "Record Type הוא טיפוס נתונים שהוצג ב-C# 9.0 המיועד ליצירת אובייקטים בלתי משתנים (immutable). הוא מספק מימוש אוטומטי של Equals, GetHashCode ו-ToString, ותומך בדפוס with-expression להעתקה עם שינויים."
    },
    {
      "question": "מהו Span<T> ב-C#?",
      "options": [
        "מבנה נתונים לגישה יעילה לזיכרון רציף",
        "סוג של מערך",
        "מחלקה גנרית רגילה",
        "מנגנון לניהול זיכרון"
      ],
      "correctAnswer": 0,
      "explain": "Span<T> הוא מבנה נתונים המאפשר גישה יעילה לזיכרון רציף, כמו מערכים או מחרוזות, ללא העתקת נתונים. זה שימושי במיוחד לשיפור ביצועים בתרחישים של עיבוד נתונים בנפח גדול."
    },
    {
      "question": "כאשר את כותבת קוד, איך את חושבת על מקרי קצה צפויים?",
      "options": [
        "אני פשוט כותבת את הקוד ורואה מה קורה",
        "בודקת את הקלט האם הוא תקין לפני שמבצעת עליו פעולות, הוספת טיפול בשגיאות אם הם מתרחשות, בדיקות תנאי, בדיקות יחידה - כתיבת בדיקות יחידה כדי לוודא שהפונקציה עובדת כצפוי מגוון רחב של תרחישים.",
        "אני מסתכל על קוד של אחרים כדי לראות איך הם מטפלים במקרי קצה",
        "אני סומך על המתורגמן/קומפיילר שיתפסו את כל השגיאות"
      ],
      "correctAnswer": 1,
      "explain": "הדרך הטובה ביותר לטפל במקרי קצה היא לשלב מספר טכניקות: תכנון קפדני, בדיקות יסודיות, טיפול בשגיאות וכתיבת בדיקות יחידה. גישה פרואקטיבית זו מבטיחה את יציבותה ואמינותה של התוכנה.\n\n"
    },
    {
      "question": "איזה שגיאות שרת את מכירה?",
      "options": [
        "שגיאות שרת הן רק בעיות בחומרה של השרת",
        "שגיאות שרת משפיעות רק על אתרי אינטרנט גדולים",
        "4XX - שגיאות צד לקוח, שגיאות שנגרמות מבקשה לא חוקית של הלקוח: 404 - השרת לא מצא את המשאב המבוקש. 403 - הרשאות לא תואמות. 401 - צריך לבצע אימות לגישה למשאב. 400 - בקשה לא חוקית, מכילה שגיאות תחביריות. 5XX - שגיאות צד שרת, שגיאות שנגרמות כתוצאה מבעיה בשרת עצמו, תקלה בקידוד, חוסר משאבים, בעיה בחיבור לרשת וכו. 500 - שגיאה כללית שמציינת בעיה פנימית בשרת, הסיבה המדוייקת אינה ידועה. 502 - השרת פועל כפרוקסי וקיבל תגובה לא חוקית משרת אחר. 503 - השרת לא זמין זמנית בגלל עומס או תחזוקה. 504 - השרת פועל כפרוקסי ולא קיבל תגובה בזמן מהשרת האחרון.",
        "שגיאות שרת הן בעיה של ספק האינטרנט ולא של מנהל האתר"
      ],
      "correctAnswer": 0,
      "explain": "שגיאות שרת הן בעיות שעלולות להתרחש בכל אתר אינטרנט. הן יכולות להיות מורכבות ולנבוע מגורמים שונים. הבנת הסוגים השונים של שגיאות השרת והגורמים להן היא חיונית עבור מפתחים ומנהלי אתרים כדי לאתר ולפתור בעיות בצורה יעילה.\n\n"
    }
  ]
}