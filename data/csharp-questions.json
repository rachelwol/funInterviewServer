{
  "questions": [
    {
      "question": "מהו ההבדל בין struct ל-class ב-C#?",
      "options": [
        "struct הוא value type ו-class הוא reference type",
        "אין הבדל משמעותי",
        "struct תמיד מוקצה על ה-heap",
        "class לא יכול לרשת מclass אחר"
      ],
      "correctAnswer": 0,
      "explain": ""
    },
    {
      "question": "מהו delegates ב-C#?",
      "options": [
        "סוג של משתנה",
        "טיפוס המייצג reference למתודה",
        "מחלקה לניהול זיכרון",
        "ממשק להורשה מרובה"
      ],
      "correctAnswer": 1,
      "explain": ""
    },
    {
      "question": "מהו async/await ב-C#?",
      "options": [
        "מנגנון לסנכרון threads",
        "דרך לכתיבת קוד אסינכרוני",
        "שיטה להרצת קוד במקביל",
        "טכניקה לניהול exceptions"
      ],
      "correctAnswer": 1,
      "explain": ""
    },
    {
      "question": "איך את מטפלת בשגיאות?",
      "options": [
        "אני בודקת את הקוד שורה שורה כדי לוודא שאין שגיאות. אם אני מוצאת שגיאה, אני מתקנת אותה ידנית.",
        "אני משתמשת ב-debugger כדי לעבור על הקוד צעד צעד ולמצוא את השגיאות.",
        "ע''י exception handling, שימוש ב try, catch ו finally.<br> try-  הינו בלוק קוד שתוכו צפויה להתרחש שגיאה. catch - הינו בלוק קוד שמתבצע כאשר מתרחשת שגיאה. finally - בלוק קוד שמתבצע תמיד, בין אם מתרחשת שגיאה ובין אם לא.",
        "אני מסתמכת על המסרים שהמחשב מציג לי כשמתרחשת שגיאה."
      ],
      "correctAnswer": 2,
      "explain": ""
    },
    {
      "question": "מהו ההבדל בין ref ל-out ב-C#?",
      "options": [
        "ref דורש אתחול המשתנה לפני השימוש, out לא",
        "אין הבדל ביניהם",
        "out משמש רק למספרים",
        "ref משמש רק למחרוזות"
      ],
      "correctAnswer": 0,
      "explain": "ההבדל העיקרי בין ref ל-out הוא שמשתנה המועבר כ-ref חייב להיות מאותחל לפני העברתו לפונקציה, בעוד שמשתנה המועבר כ-out לא חייב להיות מאותחל. בנוסף, פונקציה המקבלת פרמטר out חייבת לאתחל אותו לפני סיום הפונקציה."
    },
    {
      "question": "מהי מטרת ה-using statement?",
      "options": [
        "ייבוא מרחבי שמות",
        "שחרור משאבים באופן אוטומטי",
        "הגדרת משתנים",
        "יצירת לולאות"
      ],
      "correctAnswer": 1,
      "explain": "ה-using statement מבטיח שחרור נכון של משאבים (כמו קבצים או חיבורי מסד נתונים) על ידי קריאה אוטומטית ל-Dispose בסיום הבלוק. זה חשוב במיוחד כאשר עובדים עם משאבים מנוהלים שמיישמים את הממשק IDisposable."
    },
    {
      "question": "מהו Pattern Matching ב-C#?",
      "options": [
        "מנגנון לבדיקת והמרת טיפוסים",
        "כלי לחיפוש טקסט",
        "שיטה ליצירת אובייקטים",
        "מנגנון להשוואת מחרוזות"
      ],
      "correctAnswer": 0,
      "explain": "Pattern Matching הוא תכונה המאפשרת לבדוק את הטיפוס והערך של אובייקט בו-זמנית. זה מאפשר כתיבת קוד יותר תמציתי וקריא, במיוחד בעבודה עם מבני switch ותנאים מורכבים."
    },
    {
      "question": "מהו Record Type ב-C#?",
      "options": [
        "טיפוס נתונים בלתי משתנה",
        "מחלקה רגילה",
        "סוג של משתנה",
        "מבנה נתונים דינמי"
      ],
      "correctAnswer": 0,
      "explain": "Record Type הוא טיפוס נתונים שהוצג ב-C# 9.0 המיועד ליצירת אובייקטים בלתי משתנים (immutable). הוא מספק מימוש אוטומטי של Equals, GetHashCode ו-ToString, ותומך בדפוס with-expression להעתקה עם שינויים."
    },
    {
      "question": "מהו Span<T> ב-C#?",
      "options": [
        "מבנה נתונים לגישה יעילה לזיכרון רציף",
        "סוג של מערך",
        "מחלקה גנרית רגילה",
        "מנגנון לניהול זיכרון"
      ],
      "correctAnswer": 0,
      "explain": "Span<T> הוא מבנה נתונים המאפשר גישה יעילה לזיכרון רציף, כמו מערכים או מחרוזות, ללא העתקת נתונים. זה שימושי במיוחד לשיפור ביצועים בתרחישים של עיבוד נתונים בנפח גדול."
    }
  ]
}