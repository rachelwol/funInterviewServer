{
  "questions": [
    {
      "question": "מה ההבדל בין מערך לרשימה מקושרת? מתי תבחר באחד מהם?",
      "options": [
        "מערך הוא מבנה נתונים דינאמי בעוד שרשימה מקושרת היא סטטית.",
        "גישה לאלמנט במערך היא תמיד בזמן קבוע O(1), בעוד שברשימה מקושרת זה תלוי במיקום האלמנט.",
        "רשימות מקושרות טובות יותר להוספה והסרה של אלמנטים באמצע הרשימה, בעוד שמערכים טובים יותר לגישה לאלמנטים לפי האינדקס שלהם.",
        "מערכים תופסים מקום רצוף בזיכרון, בעוד שרשימות מקושרות מפוזרות בזיכרון."
      ],
      "correctAnswer": 2,
      "explain": "רשימות מקושרות מעולות להוספה והסרה של אלמנטים באמצע הרשימה, מכיוון שאתה רק צריך לשנות כמה מצביעים. במערך, לעומת זאת, כדי להוסיף אלמנט באמצע, אתה צריך להזיז את כל האלמנטים הבאים, מה שמייקר את הפעולה. גישה לאלמנט במערך לפי האינדקס היא מהירה מאוד (O(1)), בעוד שב רשימה מקושרת, אתה צריך לעבור על כל האלמנטים עד שתגיע למבוקש (במקרה הגרוע ביותר O(n))."
    },
    {
      "question": "הסבר את מושג הסיבוכיות של אלגוריתם. מהם הסימונים הנפוצים לסיבוכיות (O)?",
      "options": [
        "סיבוכיות אלגוריתם מתארת את כמות הזיכרון הנדרשת לאלגוריתם לפעול.",
        "סימון O מייצג את הסיבוכיות הגרועה ביותר של אלגוריתם, כלומר את הזמן המקסימלי שייקח לאלגוריתם לסיים עבור כל קלט בגודל נתון.",
        "סיבוכיות זמן לינארית O(n) פירושה שהזמן לביצוע האלגוריתם גדל באופן פרופורציוני לגודל הקלט.",
        "סיבוכיות קבועה O(1) פירושה שהזמן לביצוע האלגוריתם אינו תלוי בגודל הקלט."
      ],
      "correctAnswer": 1,
      "explain": "סימון O אכן מייצג את הסיבוכיות האסימפטוטית הגרועה ביותר של אלגוריתם. זה אומר שבמקרה הגרוע ביותר, הזמן שייקח לאלגוריתם לסיים יהיה פורפורציונאלי לפונקציה של גודל הקלט, כפי שמתואר בסימון O."
    },
    {
      "question": "מהי מחסנית (Stack)? תן דוגמה לשימוש בה בתוכנית.",
      "options": [
        "מחסנית היא מבנה נתונים לינארי שבו הוספה והוצאה מתבצעות רק מהקצה העליון, ועובדת לפי עקרון ''ראשון נכנס, אחרון יוצא'' (LIFO).",
        "מחסנית משמשת בעיקר לייצוג עצי חיפוש בינאריים.",
        "דוגמה לשימוש במחסנית היא במימוש פונקציית רקורסיה, שם המחסנית משמשת לאחסון כתובות החזרה.",
        "מחסנית היא מבנה נתונים דינמי שגודלו קבוע ואינו יכול להשתנות."
      ],
      "correctAnswer": 0,
      "explain": "זה ההגדרה המדויקת של מחסנית. היא עובדת כמו ערימה של צלחות, כאשר אתה יכול להוסיף או להוציא רק את הצלחת העליונה."
    },
    {
      "question": "מהי תור (Queue)? תן דוגמה לשימוש בה בתוכנית.",
      "options": [
        "תור הוא מבנה נתונים לינארי שבו הוספה מתבצעת מהקצה האחורי והוצאה מתבצעת מהקצה הקדמי, ועובד לפי עקרון ''ראשון נכנס, ראשון יוצא'' (FIFO).",
        "תור משמש בעיקר לייצוג עצי חיפוש בינאריים.",
        "דוגמה לשימוש בתור היא במימוש פונקציית רקורסיה, שם התור משמש לאחסון כתובות החזרה.",
        "תור הוא מבנה נתונים סטטי שגודלו קבוע ואינו יכול להשתנות."
      ],
      "correctAnswer": 0,
      "explain": "זה ההגדרה המדויקת של תור. בדומה לתור בקופה בסופר, הפריט הראשון שנכנס לתור הוא גם הראשון שיוצא."
    },
    {
      "question": "מהו עץ חיפוש בינארי (Binary Search Tree)? מה המאפיינים שלו?",
      "options": [
        "עץ חיפוש בינארי הוא עץ בינארי שבו ערך כל צומת גדול מכל הערכים בתת-העץ השמאלי שלו וקטן מכל הערכים בתת-העץ הימני שלו.",
        "עץ בינארי חיפוש תמיד מאוזן, כלומר עומק כל הענפים זהה.",
        "חיפוש אלמנט בעץ בינארי חיפוש תמיד לוקח זמן קבוע O(1).",
        "עץ בינארי חיפוש הוא מבנה נתונים דינמי, כלומר ניתן להוסיף ולמחוק ממנו אלמנטים."
      ],
      "correctAnswer": 0,
      "explain": "זה ההגדרה המדויקת של עץ בינארי חיפוש. תכונה זו מאפשרת חיפוש יעיל מאוד של אלמנטים בעץ."
    },
    {
      "question": "מה ההבדל העיקרי בין אלגוריתם מיון בועות (Bubble Sort) לאלגוריתם מיון מהיר (Quick Sort), ואיזה מהם עדיף בדרך כלל?",
      "options": [
        "מיון בועות יעיל יותר ממיון מהיר בכל המקרים, במיוחד במערכים גדולים. ",
        "מיון מהיר הוא תמיד יציב, כלומר שומר על הסדר היחסי של אלמנטים שווים, בעוד שמיון בועות אינו יציב. ",
        "מיון בועות מבוסס על השוואות חוזרות ונשנות בין זוגות אלמנטים סמוכים, בעוד שמיון מהיר משתמש בשיטה של חלוקה וכבוש כדי לחלק את המערך לחלקים קטנים יותר ולמיין אותם בנפרד.",
        "שני האלגוריתמים דומים בסיבוכיות שלהם, אך מיון בועות קל יותר למימוש."
      ],
      "correctAnswer": 2,
      "explain": "מיון בועות מבוסס על השוואות חוזרות ונשנות בין זוגות אלמנטים סמוכים, בעוד שמיון מהיר משתמש בשיטה של חלוקה וכבוש כדי לחלק את המערך לחלקים קטנים יותר ולמיין אותם בנפרד."
    },
    {
      "question": "מהי טבלת גיבוב (Hash Table)? כיצד היא פועלת? מהי התנגשות (Collision) ואיך מטפלים בה?",
      "options": [
        "טבלת גיבוב היא מבנה נתונים המאפשר גישה מהירה מאוד לכל אלמנט, אך היא סובלת מהתנגשויות רבות שאי אפשר לפתור.",
        "טבלת גיבוב פועלת על ידי שימוש בפונקציית גיבוב אשר ממירה את המפתח של כל אלמנט למספר שלם, המייצג את האינדקס של האלמנט במערך. התנגשות מתרחשת כאשר שני מפתחות שונים מתמפים לאותו אינדקס.",
        "טבלת גיבוב היא מבנה נתונים מסודר, שבו האלמנטים מסודרים לפי סדר עולה של המפתחות שלהם.",
        "התנגשות מטופלת על ידי הגדלת גודל הטבלה בכל פעם שמתרחשת התנגשות."
      ],
      "correctAnswer": 1,
      "explain": "מכיוון שהיא מתארת בצורה מדויקת את עקרון הפעולה של טבלת גיבוב, כולל השימוש בפונקציית גיבוב, התנגשויות ויעילות."
    },
    {
      "question": "מהו גרף? מה ההבדל בין גרף מכוון ללא מכוון? תן דוגמה לשימוש בגרף בבעיה מהעולם האמיתי.",
      "options": [
        "גרף הוא מבנה נתונים המייצג קשרים בין ישויות. גרף מכוון מייצג קשר חד-כיווני בין ישויות, בעוד גרף לא מכוון מייצג קשר דו-כיווני. דוגמה: רשת חברתית, שבה כל משתמש הוא צומת והקשרים ביניהם הם קשתות מכוונות (עוקב/נעקב אחריה).",
        "גרף הוא תרשים המציג נתונים מספריים בצורה ויזואלית. גרף מכוון הוא גרף שבו הקשתות מצביעות על כיוון הזרימה, בעוד גרף לא מכוון הוא גרף שבו הקשתות אינן מכוונות. דוגמה: מפת דרכים, שבה כל צומת מייצג צומת דרכים והקשתות מייצגות כבישים חד-כיווניים.",
        "גרף הוא מבנה נתונים המשמש לאחסון מידע מספרי. גרף מכוון הוא גרף שבו הקשתות מחוברות רק לצמתים מסוג מסוים, בעוד גרף לא מכוון הוא גרף שבו הקשתות יכולות לחבר כל שני צמתים. דוגמה: עץ משפחה, שבה כל אדם הוא צומת והקשרים ביניהם הם קשתות מכוונות (הורה/ילד).",
        "גרף הוא מבנה נתונים המייצג רשת של קשרים. גרף מכוון הוא גרף שבו הקשתות יכולות להיות במשקלים שונים, בעוד גרף לא מכוון הוא גרף שבו כל הקשתות בעלות אותו משקל. דוגמה: רשת האינטרנט, שבה כל אתר הוא צומת והקשרים ביניהם הם קשתות המייצגות קישורים היפר-טקסטואליים. "
      ],
      "correctAnswer": 0,
      "explain": "מכיוון שהיא מספקת הגדרה מדויקת ומקיפה של גרף, מבדילה בצורה ברורה בין סוגי גרפים ומציעה דוגמה רלוונטית."
    },
    {
      "question": "מהו אלגוריתם דינמי? מתי משתמשים בו? תן דוגמה.",
      "options": [
        "אלגוריתם דינמי הוא שיטה לפתרון בעיות על ידי פירוקן לבעיות משנה קטנות יותר ופתרון כל בעיית משנה פעם אחת בלבד, תוך שמירה של התוצאות כדי למנוע חישובים חוזרים. משתמשים בו בבעיות אופטימיזציה שבהן יש חפיפה בין תת-הבעיות. דוגמה: חישוב המסלול הקצר ביותר בין שני צמתים בגרף.",
        "אלגוריתם דינמי הוא אלגוריתם רקורסיבי שמבוסס על חלוקה של הבעיה לחלקים קטנים יותר. משתמשים בו בבעיות ספירה, כמו למשל חישוב מספר האפשרויות לבחור k כדורים מתוך n כדורים שונים.",
        "אלגוריתם דינמי הוא אלגוריתם יעיל במיוחד לפתרון בעיות סידור, כמו מיון מערך. משתמשים בו כאשר הסדר של הפעולות אינו חשוב.",
        "אלגוריתם דינמי הוא אלגוריתם שמשתמש בטבלה כדי לשמור את התוצאות של חישובים קודמים. משתמשים בו רק בבעיות שבהן יש צורך לחשב את כל הפתרונות האפשריים."
      ],
      "correctAnswer": 0,
      "explain": "תשובה 1 היא הנכונה מכיוון שהיא מספקת הגדרה מדויקת ומקיפה של אלגוריתם דינמי, מציינת את היישומים העיקריים שלו ומספקת דוגמה רלוונטית."
    },
    {
      "question": "הסבר את מושג העץ האדום-שחור. מה המאפיינים שלו?",
      "options": [
        "עץ אדום-שחור הוא גרף מכוון שבו הקשתות מסומנות באדום או בשחור. הוא משמש לייצוג מערכות מדיניות, כאשר הצבעים מייצגים רמות שונות של חשיבות. מאפיינים עיקריים: כל צומת יכול להיות מחובר לכל צומת אחר, והצבע של הקשת קובע את סוג הקשר.",
        "עץ אדום-שחור הוא מבנה נתונים דינמי המשמש לאחסון מידע מספרי. הוא מבוסס על סידור של מספרים לפי גודלם, כאשר הצבעים מייצגים את הזוגיות של המספר. מאפיינים עיקריים: כל צומת מכיל מספר, והצבע שלו קובע אם המספר זוגי או אי-זוגי. ",
        "עץ אדום-שחור הוא מבנה נתונים סטטי המשמש לייצוג היררכיות. הוא דומה לעץ משפחה, כאשר הצבעים מייצגים את המין של האדם. מאפיינים עיקריים: השורש מייצג את האב הקדמון, והעלים מייצגים את הדורות הצעירים.",
        "עץ אדום-שחור הוא מבנה נתונים מסוג עץ חיפוש בינארי מאוזן בקירוב. כל צומת בעץ מסומן כאדום או שחור, כאשר ישנם כללים קפדניים לגבי מיקום הצמתים האדומים והשחורים. מאפיינים עיקריים: כל עלה הוא שחור, כל צומת אדום חייב להיות בעל שני בנים שחורים, וכל מסלול מהשורש לכל עלה מכיל את אותו מספר של צמתים שחורים."
      ],
      "correctAnswer": 3,
      "explain": "מכיוון שהיא מספקת הגדרה מדויקת ומקיפה של עץ אדום-שחור, ומציינת את המאפיינים החשובים ביותר שלו."
    },
    {
      "question": "באיזה מבנה נתונים היית משתמש לייצוג רשת חברתית? נמק את בחירתך.",
      "options": [
        "מערך דו ממדי",
        "גרף",
        "עץ חיפוש בינארי",
        "רשימה מקושרת"
      ],
      "correctAnswer": 1,
      "explain": "גרף הוא הבחירה הטבעית ביותר לייצוג רשת חברתית. כל משתמש ברשת הוא צומת בגרף, והקשרים ביניהם (חברות, עוקב/נעקב) מיוצגים על ידי קשתות. גרף מאפשר לנו לבצע מגוון רחב של ניתוחים על הרשת, כמו מציאת חברים משותפים, חישוב המרחק החברתי בין משתמשים, וגילוי קהילות"
    },
    {
      "question": "תאר אלגוריתם יעיל למציאת המספר החסר במערך של מספרים שלמים מ-1 עד n, כאשר רק מספר אחד חסר.",
      "options": [
        "חישוב סכום: נחשב את סכום כל המספרים מ-1 עד n (n*(n+1)/2). לאחר מכן, נחשב את סכום המספרים במערך. ההפרש בין שני הסכומים יהיה המספר החסר. אלגוריתם זה יעיל מאוד מבחינת סיבוכיות זמן (O(n)).",
        "מיון: נמיין את המערך בסדר עולה. נעבור על המערך מסודר ונשווה כל איבר למדד שלו במערך. האיבר הראשון שבו לא מתקיים השוויון מצביע על המספר החסר. סיבוכיות זמן תלויה באלגוריתם המיון שנבחר (למשל, מיון מהיר: O(n log n)). ",
        "שימוש במערך עזר: נבנה מערך עזר באורך n, ונתחיל את כל האיברים ב-0. נעבור על המערך המקורי, ובכל איטרציה נסמן 1 במערך העזר במקום המתאים למספר הנוכחי. בסוף, האינדקס שבו נשאר 0 במערך העזר מצביע על המספר החסר. סיבוכיות זמן היא O(n), אך דורשת שימוש במערך עזר נוסף.",
        "חיפוש בינארי: נבצע חיפוש בינארי במערך כדי למצוא את המספר החסר. אלגוריתם זה יעיל רק אם המערך ממויין. מכיוון שהמערך אינו בהכרח ממויין, חיפוש בינארי אינו מתאים לבעיה זו"
      ],
      "correctAnswer": 0,
      "explain": "החישוב הישיר של סכום המספרים הוא השיטה היעילה והפשוטה ביותר למציאת המספר החסר במערך."
    },
    {
      "question": "הסבר את החשיבות של בחירת מבנה נתונים מתאים לפתרון בעיה מסוימת.",
      "options": [
        "מבנה הנתונים אינו חשוב כל כך, העיקר שהאלגוריתם יהיה נכון. כל מבנה נתונים יכול לשמש לפתרון כל בעיה, רק שהאלגוריתם יהיה מורכב יותר. לדוגמה, ניתן להשתמש ברשימה מקושרת כדי לייצג מערך, אך זה יאט את ביצועי האלגוריתם.",
        "בחירת מבנה נתונים היא עניין של העדפה אישית של המפתח, ולא משפיעה בצורה משמעותית על ביצועי התוכנית. כל מבנה נתונים יכול לשמש לפתרון כל בעיה, העיקר שהקוד יקרא טוב.",
        "מבנה הנתונים צריך להתאים לשפת התכנות בה משתמשים. כל שפת תכנות תומכת במבני נתונים שונים, ולכן יש לבחור את המבנה המתאים לשפה.",
        "בחירת מבנה נתונים מתאים היא קריטית ליעילות האלגוריתם. מבנה נתונים שמתאים לבעיה מאפשר גישה מהירה לנתונים, ביצוע פעולות בצורה יעילה יותר, וחיסכון בזמן ובמקום בזיכרון. לדוגמה, אם נרצה למצוא את האיבר הקטן ביותר במערך, מערך מסודר יהיה יעיל יותר מאשר מערך לא מסודר."
      ],
      "correctAnswer": 3,
      "explain": "ד' נכונה: בחירת מבנה נתונים מתאים היא שלב קריטי בתכנון אלגוריתם. מבנה נתונים טוב יכול לשפר משמעותית את יעילות האלגוריתם, להפחית את סיבוכיותו ולשפר את קריאות הקוד."
    },
    {
      "question": "מהו מבנה הנתונים המתאים ביותר לייצוג מילון (dictionary) בשפה כמו פייתון?",
      "options": [
        "מערך",
        "רשימה מקושרת",
        "עץ חיפוש בינארי",
        "טבלת גיבוב (Hash Table)"
      ],
      "correctAnswer": 3,
      "explain": "ד' נכונה: טבלת גיבוב היא מבנה הנתונים האידיאלי לייצוג מילון בשפות כמו פייתון. הסיבה לכך היא שהיא מאפשרת גישה מהירה מאוד לערכים על ידי שימוש במפתחות."
    },
    {
      "question": "מהו מערך?",
      "options": [
        "מערך הוא אוסף של נתונים שונים, שאינם קשורים זה לזה.",
        "מערך הוא מבנה נתונים לינארי, כלומר אוסף סדור של אלמנטים מאותו סוג נתונים, המאוחסנים ברצף בזיכרון המחשב. לכל אלמנט במערך יש אינדקס ייחודי, שמשמש לגישה ישירה לאלמנט זה.",
        "אינדקס של אלמנט במערך יכול להיות כל מספר, חיובי או שלילי",
        "גודל מערך יכול להשתנות באופן דינמי במהלך ביצוע התוכנית"
      ],
      "correctAnswer": 1,
      "explain": "מערך הוא מבנה נתונים בסיסי וחשוב בתכנות, המאפשר אחסון וגישה יעילה לאוסף של נתונים מאותו סוג. הבנת המושגים אינדקס, גודל מערך וסוג נתונים היא חיונית לעבודה עם מערכים."
    },
    {
      "question": "מהם היתרונות והחסרונות של שימוש במערך לעומת מבני נתונים אחרים כמו רשימה מקושרת?",
      "options": [
        "רשימות מקושרות תופסות פחות מקום בזיכרון ממערכים.",
        "מערכים תמיד יעילים יותר מרשימות מקושרות",
        "מערכים: מציעים גישה ישירה מהירה מאוד לאלמנטים באמצעות אינדקס, אך גמישותם מוגבלת. הוספה ומחיקה של אלמנטים באמצע המערך עלולות להיות יקרות מבחינת זמן חישוב, שכן דורשות הזזה של כל האלמנטים הבאים. רשימות מקושרות: מאפשרות הוספה ומחיקה יעילות של אלמנטים בכל מקום ברשימה, אך גישה לאלמנט ספציפי דורשת איטרציה על כל האלמנטים הקודמים.",
        "אין צורך לדעת את גודל המערך מראש, ניתן להוסיף אלמנטים בכל עת."
      ],
      "correctAnswer": 2,
      "explain": "בחירת מבנה הנתונים המתאים היא החלטה חשובה בתכנות. יש לשקול את היתרונות והחסרונות של כל מבנה נתונים בהקשר של הבעיה הספציפית."
    },
    {
      "question": "כיצד גובשים אלמנטים במערך? מהי סיבוכיות הזמן של גישה לאלמנט מסוים במערך?",
      "options": [
        "אלמנטים במערך גובשים בצורה רציפה בזיכרון המחשב, כלומר אחד אחרי השני. לכל אלמנט במערך יש אינדקס ייחודי, שמשמש לגישה ישירה אליו. סיבוכיות הזמן של גישה לאלמנט מסוים במערך היא קבועה (O(1)), כלומר הזמן שנדרש לגשת לאלמנט אינו תלוי בגודל המערך.",
        "אלמנטים במערך גובשים באופן אקראי בזיכרון, ולכן גישה לאלמנט מסוים דורשת חיפוש לינארי.",
        "סיבוכיות הזמן של גישה לאלמנט במערך היא לינארית (O(n)), כלומר הזמן גדל יחסית לגודל המערך.",
        "אי אפשר לגשת ישירות לאלמנט במערך, אלא רק באמצעות איטרציה על כל האלמנטים הקודמים לו."
      ],
      "correctAnswer": 0,
      "explain": "מערכים מציעים יתרון משמעותי מבחינת מהירות גישה לאלמנטים. תכונה זו הופכת אותם למבנה נתונים פופולרי עבור יישומים שבהם נדרשת גישה מהירה לאלמנטים לפי האינדקס שלהם."
    },
    {
      "question": "מהי החשיבות של הגדרת גודל מערך מראש? מה קורה אם ננסה לגשת לאינדקס שאינו קיים במערך?",
      "options": [
        "הגדרת גודל מערך מראש אינה חשובה, ניתן להוסיף אלמנטים למערך בכל עת.",
        "הגדרת גודל מערך מראש היא קריטית מכיוון שהיא קובעת את כמות הזיכרון שהמחשב יקצה למערך. גודל זה קבוע לאחר ההקצאה, וניסיון לגשת לאינדקס שאינו קיים בטווח האינדקסים החוקיים של המערך יגרום לשגיאת זמן ריצה (runtime error).",
        "אם ננסה לגשת לאינדקס שאינו קיים במערך, התוכנית תמשיך להתבצע כרגיל, אך הערך שיתקבל יהיה אפס.",
        "הגדרת גודל מערך מראש היא חשובה רק למערכים תלת-ממדיים."
      ],
      "correctAnswer": 1,
      "explain": "הגדרת גודל מערך מראש היא חשובה מכיוון שהיא מבטיחה ניהול יעיל של הזיכרון ומניעת שגיאות בזמן הריצה. חשוב לוודא שהגודל שנקבע הוא מספיק גדול כדי להכיל את כל הנתונים הנדרשים, אך לא גדול מדי כדי למנוע בזבוז של זיכרון."
    },
    {
      "question": "מהי סיבוכיות הזמן של הפעולות הבאות במערך: הוספה, מחיקה, חיפוש?",
      "options": [
        "מחיקת אלמנט ממערך תמיד לוקחת זמן קבוע (O(1)",
        "כל הפעולות במערך הן בעלות סיבוכיות זמן קבועה (O(1)",
        "חיפוש אלמנט במערך ממוין הוא תמיד בעלת סיבוכיות זמן לוגריתמית (O(log n)",
        "הוספה: O(n) - בדרך כלל, כדי להוסיף אלמנט למערך, יש להזיז את כל האלמנטים הבאים מקום אחד קדימה, מה שדורש פעולות פרופורציונליות לגודל המערך, מחיקה: O(n) - בדומה להוספה, מחיקה גם היא דורשת הזזה של אלמנטים, מה שמוביל לסיבוכיות לינארית, חיפוש: O(n) - במקרה הכללי, חיפוש אלמנט במערך דורש סריקה סדרתית של כל האלמנטים, מה שדורש זמן פרופורציונלי לגודל המערך. סיבוכיות הזמן המוזכרת כאן מתייחסת למערכים סטטיים. במערכים דינמיים, ניתן לייעל את פעולות ההוספה והמחיקה במקרים מסוימים, אך הסיבוכיות הכללית נשארת בדרך כלל O(n)."
      ],
      "correctAnswer": 3,
      "explain": "מערכים מציעים גישה מהירה מאוד לאלמנטים לפי האינדקס שלהם, אך פעולות כמו הוספה ומחיקה יכולות להיות יקרות מבחינת זמן חישוב, במיוחד במערכים גדולים. הבנת סיבוכיות הזמן של פעולות שונות במערך היא קריטית לבחירת מבנה הנתונים המתאים לפתרון בעיה מסוימת."
    },
    {
      "question": "כיצד מבצעים מיון מערך?",
      "options": [
        "מיון מערך תמיד לוקח זמן קבוע, ללא תלות בגודל המערך.",
        "מיון מערך תמיד מתבצע באותו אופן, ללא תלות בסוג הנתונים או בגודל המערך",
        "מיון מערך הוא תהליך של סידור אלמנטים במערך בסדר עולה או יורד. ישנם אלגוריתמים רבים למיון מערכים, כל אחד עם סיבוכיות זמן שונה המתאימה למקרים שונים. כמה מהאלגוריתמים הנפוצים כוללים:",
        "מיון מערך הוא תהליך חד-פעמי ולא ניתן לחזור עליו."
      ],
      "correctAnswer": 2,
      "explain": "מיון מערך הוא פעולה בסיסית בתכנות, שיש לה יישומים רבים. הבנת עקרונות המיון השונים והבחירה באלגוריתם המתאים היא מיומנות חשובה לכל מתכנת."
    },
    {
      "question": "מהו מיון בועות?",
      "options": [
        "מיון בועות הוא האלגוריתם המהיר ביותר למיון מערכים בכל מצב.",
        "מיון בועות אינו דורש השוואות בין אלמנטים.",
        "מיון בועות מסדר את המערך בסדר יורד בלבד.",
        "מיון בועות הוא אלגוריתם מיון פשוט יחסית, אך בדרך כלל לא יעיל עבור מערכים גדולים. האלגוריתם עובד על ידי השוואה חוזרת ונשנית של זוגות אלמנטים סמוכים במערך. אם שני האלמנטים אינם בסדר הרצוי (כלומר, האלמנט הגדול יותר מופיע לפני הקטן יותר), הם מתחלפים. התהליך חוזר על עצמו עד שהמערך כולו ממוין."
      ],
      "correctAnswer": 3,
      "explain": "מיון בועות הוא אלגוריתם בסיסי ללימוד, אך הוא אינו האלגוריתם המועדף למיון מערכים גדולים בשל יעילותו הנמוכה. הבנת עקרונותיו עוזרת להבין את הרעיון הבסיסי של מיון ולהשוות אותו לאלגוריתמים מתקדמים יותר."
    },
    {
      "question": "מהו מיון הכנסה (Insertion Sort)?",
      "options": [
        "מיון הכנסה הוא אלגוריתם מיון פשוט ויעיל יחסית למערכים קטנים או מערכים שכבר ממויינים ברובו. האלגוריתם עובד על ידי בניית תת-מערך ממוין בהדרגה. בכל איטרציה, האלמנט הבא במערך נלקח והוכנס למקומו הנכון בתת-המערך הממוין הקיים. זה נעשה על ידי השוואת האלמנט הנוכחי עם האלמנטים הקודמים בתת-המערך הממוין והזזת אלמנטים גדולים יותר מקום אחד קדימה עד למציאת המקום הנכון להכניס את האלמנט הנוכחי.",
        "מיון הכנסה תמיד מהיר יותר מכל אלגוריתם מיון אחר.",
        "מיון הכנסה אינו דורש השוואות בין אלמנטים.",
        "מיון הכנסה תמיד מסדר את המערך בסדר יורד."
      ],
      "correctAnswer": 0,
      "explain": "מיון הכנסה הוא אלגוריתם מיון פשוט ואינטואיטיבי, שיכול להיות שימושי במצבים מסוימים. הבנת עקרונותיו עוזרת להבין את הרעיון הבסיסי של מיון ולהשוות אותו לאלגוריתמים מתקדמים יותר."
    },
    {
      "question": "מהו מיון בחירה (Selection Sort)?",
      "options": [
        "מיון בחירה הוא אלגוריתם מיון פשוט יחסית, אך לא יעיל במיוחד עבור מערכים גדולים. האלגוריתם עובד על ידי חיפוש האלמנט הקטן ביותר במערך בכל איטרציה והחלפתו עם האלמנט הראשון במערך הלא ממוין. התהליך חוזר על עצמו על שאר האלמנטים עד שהמערך כולו ממוין.",
        "מיון בחירה הוא אלגוריתם מיון פשוט יחסית, אך לא יעיל במיוחד עבור מערכים גדולים. האלגוריתם עובד על ידי חיפוש האלמנט הקטן ביותר במערך בכל איטרציה והחלפתו עם האלמנט הראשון במערך הלא ממוין. התהליך חוזר על עצמו על שאר האלמנטים עד שהמערך כולו ממוין.",
        "מיון בחירה אינו דורש השוואות בין אלמנטים.",
        "מיון בחירה מסדר את המערך בסדר יורד בלבד."
      ],
      "correctAnswer": 1,
      "explain": "מיון בחירה הוא אלגוריתם בסיסי ללימוד, אך הוא אינו האלגוריתם המועדף למיון מערכים גדולים בשל יעילותו הנמוכה. הבנת עקרונותיו עוזרת להבין את הרעיון הבסיסי של מיון ולהשוות אותו לאלגוריתמים מתקדמים יותר."
    },
    {
      "question": "מהו מיון מהיר (Quick Sort)?",
      "options": [
        "מיון מהיר תמיד מסיים את העבודה בכמות קבועה של צעדים, ללא קשר לגודל המערך.",
        "מיון מהיר אינו דורש השוואות בין אלמנטים.",
        "מיון מהיר הוא האלגוריתם היחיד שיכול למיין מערכים.",
        "מיון מהיר הוא אלגוריתם מיון יעיל מאוד, שמבוסס על עיקרון \"חלק וכבוש\". הוא בוחר איבר אקראי מהמערך, מחלק את המערך לשלושה חלקים (קטנים מהאיבר, שווים לו וגדולים ממנו), ומיישם את אותו תהליך על כל חלק בנפרד. התהליך חוזר על עצמו עד שהמערך כולו ממוין."
      ],
      "correctAnswer": 3,
      "explain": "מיון מהיר הוא אלגוריתם מיון חזק ויעיל, המשמש במגוון רחב של יישומים. הבנת עקרונותיו מאפשרת לבחור את אלגוריתם המיון המתאים ביותר עבור כל בעיה ספציפית."
    },
    {
      "question": "מהו מהו מיון מיזוג (Merge Sort)?",
      "options": [
        "מיון מיזוג הוא האלגוריתם היחיד שיכול למיין מערכים.",
        "מיון מיזוג אינו דורש השוואות בין אלמנטים.",
        "מיון מיזוג הוא אלגוריתם מיון יעיל מאוד, שמבוסס על עקרון \"חלק וכבוש\". הוא עובד כך: חלוקה: מחלק את המערך לשני חצאים שווים, מיון רקורסיבי: ממיין כל חצי בנפרד, באותו אופן, מיזוג: משלב את שני החצאים הממוינים לחצי אחד ממוין, על ידי השוואה בין האיברים של שני החצאים והכנסה שלהם למערך חדש בסדר הנכון.",
        "מיון מיזוג הוא פחות יעיל ממיון בועות עבור מערכים גדולים."
      ],
      "correctAnswer": 2,
      "explain": "מיון מיזוג הוא אלגוריתם מיון חזק ויעיל, המבוסס על עקרון \"חלק וכבוש\". הוא משמש במגוון רחב של יישומים, במיוחד כאשר יש צורך במיון יציב או כאשר סיבוכיות זמן ריצה קבועה היא קריטית.\n\n\n\n\n\n"
    },
    {
      "question": "מה ההבדל בין מיון בועות, מיון מהיר ומיון מיזוג?",
      "options": [
        "מיון בועות, מיון מהיר ומיון מיזוג הם שלושה שמות שונים לאותו אלגוריתם מיון, רק עם יישומים שונים. ",
        "כל שלושת האלגוריתמים הללו הם בעלי סיבוכיות זמן לינארית (O(n), מה שהופך אותם ליעילים מאוד בכל מצב. ",
        "מיון בועות: אלגוריתם פשוט אך לא יעיל, משווה זוגות עוקבים ומחליף אם בסדר לא נכון. סיבוכיות זמן: O(n²), מיון מהיר: אלגוריתם יעיל מבוסס על \"חלק וכבוש\", בוחר ציר ומחלק את המערך. סיבוכיות זמן ממוצעת: O(n log n), מיון מיזוג: אלגוריתם יציב, מחלק את המערך לשניים, ממינה כל חצי בנפרד וממזג. סיבוכיות זמן: O(n log n).",
        "מיון מהיר הוא תמיד האלגוריתם המהיר ביותר למיון מערך, ללא קשר לגודל המערך או לסוג הנתונים. "
      ],
      "correctAnswer": 2,
      "explain": "כל אחד משלושת האלגוריתמים הללו מתאים למצבים שונים. מיון בועות פשוט להבנה אך איטי, מיון מהיר הוא מהיר מאוד בממוצע אך יכול להיות פחות יעיל במקרים מסוימים, ומיון מיזוג הוא יציב ויעיל אך עלול להיות פחות יעיל ממיון מהיר בממוצע. הבחירה באלגוריתם המתאים תלויה בגודל המערך, במידת המיון הראשוני של המערך ובדרישות נוספות כמו יציבות.\n\n\n\n\n\n"
    },
    {
      "question": "מהי מטריצה? כיצד מייצגים מטריצה באמצעות מערך?",
      "options": [
        "מטריצה היא מבנה נתונים דו-ממדי המשמש לייצוג אוסף של מספרים או ערכים מסודרים בשורות ועמודות. כל מספר במטריצה נקרא איבר, והמיקום של כל איבר נקבע על ידי השורה והעמודה שלו.  כדי לייצג מטריצה באמצעות מערך, אנו משתמשים במערך דו-ממדי. כל שורה במטריצה מתאימה לשורה במערך, וכל עמודה במטריצה מתאימה לעמודה במערך. לדוגמה, כדי לייצג מטריצה בגודל 3x3, נוכל להשתמש במערך דו-ממדי בגודל 3x3.",
        "מטריצה היא רשימה של מספרים, וניתן לייצג אותה באמצעות מערך חד-ממדי. ",
        "מטריצה היא מבנה נתונים המשמש רק לייצוג מספרים שלמים. ",
        "אי אפשר לייצג מטריצה באמצעות מערך, מכיוון שמטריצה היא מבנה מורכב יותר ממערך."
      ],
      "correctAnswer": 0,
      "explain": "מטריצות הן כלי חשוב מאוד בתחומים רבים, כגון מתמטיקה, מדעי המחשב והנדסה. ההבנה כיצד לייצג מטריצות באמצעות מערכים היא בסיסית לתכנות עם מטריצות."
    },
    {
      "question": "ציין דוגמאות לשימושים נפוצים של מערכים בתכנות.",
      "options": [
        "מערכים משמשים רק לאחסון מספרים שלמים.",
        "מערכים משמשים במגוון רחב של יישומים בתכנות. לדוגמא: אחסון רשימות של נתונים מאותו סוג: למשל, רשימה של ציונים במבחן, ייצוג מטריצות, מימוש מבני נתונים אחרים כמו ערימות, תורים, מחסניות ורשימות מקושרות, טבלאות גיבוב מבוססות לעיתים קרובות על מערכים, מערכים משמשים לאחסון זמני של נתונים במהלך ביצוע חישובים או אלגוריתמים, מערכים משמשים לייצוג תמונות, תבניות ונתונים גרפיים אחרים.",
        "מערכים אינם יעילים לאחסון נתונים גדולים. ",
        "מערכים משמשים בעיקר בשפות תכנות מיושנות, ולא בשפות תכנות מודרניות."
      ],
      "correctAnswer": 1,
      "explain": "מערכים הם כלי בסיסי ורב-שימושי בתכנות. ההבנה שלהם היא חיונית לכל מתכנת."
    },
    {
      "question": "כיצד ניתן להשתמש במערך לייצוג מחרוזת?",
      "options": [
        "מחרוזת יכולה להיוצג כמערך של תווים. כל תו במחרוזת תופס מקום אחד במערך. לדוגמה, המחרוזת \"שלום\" תיוצג כמערך באורך 5, כאשר כל תא במערך יכיל תו אחד: 'ש', 'ל', 'ו', 'ם'.",
        "מחרוזת יכולה להיוצג רק כמערך של מספרים. ",
        "אין צורך במערך כדי לייצג מחרוזת, ניתן להשתמש בכל מבנה נתונים אחר.",
        "מערך יכול לייצג רק מחרוזות באורך קבוע, שאינו משתנה."
      ],
      "correctAnswer": 0,
      "explain": "מערכים הם כלי יעיל לייצוג מחרוזות בשפות תכנות רבות. הבנת הקשר בין מחרוזות ומערכים היא חיונית לתכנות בסיסי.\n\n\n\n\n\n\n\n\n"
    },
    {
      "question": "מהו מערך דו-ממדי?",
      "options": [
        "אי אפשר לבצע פעולות מתמטיות על מערכים דו-ממדיים. ",
        "מערך דו-ממדי הוא רשימה פשוטה של מספרים.",
        "מערך דו-ממדי הוא מבנה נתונים המורכב משורות ועמודות, בדומה לטבלה. כל תא במערך הדו-ממדי מכיל ערך יחיד, והגישה אליו מתבצעת באמצעות שני אינדקסים: אינדקס לשורה ואינדקס לעמודה.",
        "מערך דו-ממדי יכול להכיל רק מספרים שלמים. "
      ],
      "correctAnswer": 2,
      "explain": "מערכים דו-ממדיים הם כלי חשוב מאוד בתכנות, המשמשים לייצוג מגוון רחב של נתונים. ההבנה שלהם היא חיונית לפתרון בעיות רבות בתחומי מדעי המחשב השונים.\n\n\n\n\n\n\n\n\n"
    },
    {
      "question": "כיצד ניגשים לאלמנט במערך דו-ממדי?",
      "options": [
        "כדי לגשת לאלמנט במערך דו-ממדי, מספיק לציין את האינדקס הכללי שלו. ",
        "אי אפשר לגשת לאלמנט במערך דו-ממדי ישירות, רק באמצעות לולאה.",
        "כדי לגשת לאלמנט ספציפי במערך דו-ממדי, יש לציין את האינדקסים של השורה והעמודה שלו. האינדקסים מתחילים בדרך כלל מ-0. לדוגמה, כדי לגשת לאלמנט בשורה השנייה ועמודה השלישית במערך דו-ממדי בשם my_array, נכתוב: my_array[1][2].",
        "כדי לגשת לאלמנט במערך דו-ממדי, יש להשתמש בפונקציה מיוחדת."
      ],
      "correctAnswer": 2,
      "explain": "הגישה לאלמנטים במערך דו-ממדי היא מיומנות בסיסית בתכנות. הבנת איך לעשות זאת מאפשרת לבצע מגוון רחב של פעולות על נתונים מאורגנים בטבלאות."
    },
    {
      "question": "מהו מערך דינאמי ומה ההבדל בינו לבין למערך רגיל?",
      "options": [
        "מערך דינאמי הוא מבנה נתונים שגודלו יכול להשתנות בזמן הריצה של התוכנית. בניגוד למערך רגיל, שבו הגודל נקבע מראש בעת ההקצאה, מערך דינאמי מאפשר להוסיף או להסיר אלמנטים במהלך ביצוע התוכנית, וכך להתאים את גודלו לצרכים המשתנים של היישום.",
        "מערך דינאמי הוא סוג של מערך שמאפשר גישה לאלמנטים בצורה מהירה יותר ממערך רגיל.",
        "מערך דינאמי הוא מערך שכל האלמנטים בו הם מסוגים שונים.",
        "מערך דינאמי הוא מערך שמאפשר רק קריאה לאלמנטים, ולא כתיבה."
      ],
      "correctAnswer": 0,
      "explain": "המערך הדינאמי מציע גמישות רבה יותר ממערך רגיל, אך הוא גם דורש ניהול זיכרון קפדני יותר כדי למנוע דליפות זיכרון. הבחירה בין מערך דינאמי למערך רגיל תלויה בצרכים הספציפיים של היישום."
    },
    {
      "question": "כיצד ניתן לייעל את פעולות ההוספה והמחיקה במערך כאשר איננו יודעים מראש את הגודל הסופי שלו?",
      "options": [
        "להמשיך להשתמש במערך רגיל ולהגדיל את גודלו בכל פעם שצריך להוסיף אלמנט. ",
        "להשתמש במערך דו-ממדי כדי לאפשר גמישות רבה יותר בגודל.",
        "להשתמש במערך קבוע בגודל מקסימלי אפשרי כדי להימנע מבעיות של גודל.",
        "כדי לייעל את פעולות ההוספה והמחיקה במערך כאשר הגודל הסופי אינו ידוע מראש, ניתן להשתמש במבנה נתונים דינאמי כמו רשימה מקושרת או מערך דינאמי המבוסס על הקצאה מחדש, מבנים דינמיים אלו מאפשרים הוספה והסרה של אלמנטים בכל מקום ברשימה בצורה יעילה. וכן שינוי גודל המבנה הנתונים בזמן ריצה ללא הצורך בהקצאה מחדש של כל המערך."
      ],
      "correctAnswer": 3,
      "explain": "בעת עבודה עם נתונים שגודלם אינו ידוע מראש, מומלץ להשתמש במבנים דינמיים כמו רשימות מקושרות או מערכים דינמיים כדי להשיג ביצועים טובים יותר וגמישות רבה יותר."
    },
    {
      "question": "מהי סיבוכיות הזמן של פעולות שונות במערך בתנאים הטובים ביותר, הגרועים ביותר ובממוצע?",
      "options": [
        "כל הפעולות במערך הן תמיד O(1).",
        "גישה לאלמנט: O(1) - בכל המקרים, חיפוש: הטוב ביותר O(1) - אם האלמנט נמצא במקום הראשון, הגרוע ביותר O(n) - אם האלמנט נמצא במקום האחרון או שאינו קיים במערך, הממוצע O(n) - בממוצע, נצטרך לבדוק חצי מהאלמנטים במערך. הוספה: הטוב ביותר O(1) - אם יש מקום פנוי בסוף המערך, הגרוע ביותר O(n) - אם צריך להזיז את כל האלמנטים כדי לפנות מקום, הממוצע תלוי באסטרטגיית ההוספה. אם מוסיפים בסוף, זה O(1), אבל אם מוסיפים באמצע, זה O(n) בממוצע, מחיקה: הטוב ביותר O(1) - אם מוחקים את האלמנט האחרון, הגרוע ביותר O(n) - אם מוחקים את האלמנט הראשון וצריך להזיז את כל האלמנטים, הממוצע תלוי באסטרטגיית המחיקה. אם מוחקים באמצע, זה O(n) בממוצע.",
        "סיבוכיות הזמן של כל הפעולות במערך היא תמיד O(n). ",
        "גישה לאלמנט: O(1) - בכל המקרים, חיפוש: הטוב ביותר O(1) - אם האלמנט נמצא במקום הראשון, הגרוע ביותר O(n) - אם האלמנט נמצא במקום האחרון או שאינו קיים במערך, הממוצע O(n) - בממוצע, נצטרך לבדוק חצי מהאלמנטים במערך. הוספה: הטוב ביותר O(1) - אם יש מקום פנוי בסוף המערך, הגרוע ביותר O(nlogn) - אם צריך להזיז את כל האלמנטים כדי לפנות מקום, הממוצע תלוי באסטרטגיית ההוספה. אם מוסיפים בסוף, זה O(1), אבל אם מוסיפים באמצע, זה O(n) בממוצע, מחיקה: הטוב ביותר O(1) - אם מוחקים את האלמנט האחרון, הגרוע ביותר O(n) - אם מוחקים את האלמנט הראשון וצריך להזיז את כל האלמנטים, הממוצע תלוי באסטרטגיית המחיקה. אם מוחקים באמצע, זה O(nlogn) בממוצע."
      ],
      "correctAnswer": 1,
      "explain": "הבנת סיבוכיות הזמן של פעולות במערך היא קריטית לבחירת מבנה הנתונים המתאים ליישום. כאשר הבחירה היא בין מערך לרשימה מקושרת, למשל, סיבוכיות הזמן של פעולות שונות יכולה להשפיע על הביצועים הכוללים של התוכנית."
    },
    {
      "question": "כיצד השוואת בין סיבוכיות הזמן של מערך לרשימה מקושרת עבור פעולות שונות?",
      "options": [
        "רשימה מקושרת תמיד יעילה יותר ממערך.",
        "סיבוכיות הזמן של מערך ורשימה מקושרת זהה עבור כל הפעולות.",
        "מערך: גישה מהירה, הוספה ומחיקה מהירה(בדרך כלל), רשימה מקושרת: גישה מהירה, הוספה ומחיקה איטיות(במקומות מסוימים). בחירת מבנה הנתונים תלויה בפעולות הנפוצות ביישום, לדוגמה: אם צריך לגשת לאלמנטים הרבה פעמים, רשימה מקושרת תהיה יעילה יותר. אם צריך להוסיף ולהסיר אלמנטים באמצע הרשימה לעתים קרובות, מערך יהיה עדיף.",
        "מערך: גישה מהירה, הוספה ומחיקה איטיות (בדרך כלל), רשימה מקושרת: גישה איטית, הוספה ומחיקה מהירות (במקומות מסוימים). בחירת מבנה הנתונים תלויה בפעולות הנפוצות ביישום, לדוגמה: אם צריך לגשת לאלמנטים הרבה פעמים, מערך יהיה יעיל יותר. אם צריך להוסיף ולהסיר אלמנטים באמצע הרשימה לעתים קרובות, רשימה מקושרת תהיה עדיפה."
      ],
      "correctAnswer": 3,
      "explain": "בחירת מבנה הנתונים המתאים תלויה בסוג הפעולות שנבצע עליו ובסיבוכיות הזמן הרצויה. יש לשקול את היתרונות והחסרונות של כל מבנה נתונים בהקשר הספציפי של הבעיה.\n\n"
    },
    {
      "question": "תאר מצב שבו מערך הוא מבנה הנתונים המתאים ביותר לפתרון בעיה מסוימת.",
      "options": [
        "מצב: ברצונך ליצור רשימת משימות שבה אתה יכול להוסיף ולהסיר משימות באופן שרירותי במהלך היום.  הסבר: רשימה מקושרת תהיה מתאימה יותר למצב זה, מכיוון שהיא מאפשרת הוספה ומחיקה של אלמנטים באמצע הרשימה בצורה יעילה.",
        "מצב: ברצונך ליצור תוכנית שתחשב את הממוצע של ציוני מבחן של 100 תלמידים.  הסבר:  גישה ישירה: במערך, ניתן לגשת לכל ציון באופן ישיר באמצעות האינדקס שלו. זה מאפשר חישוב מהיר של סכום הציונים וחישוב הממוצע. גודל קבוע: מספר התלמידים ידוע מראש (100), ולכן ניתן להקצות מערך בגודל מדויק, ללא צורך בניהול דינאמי של הזיכרון. פשוט ליישום: חישוב הממוצע במערך הוא פעולה פשוטה ואינטואיטיבית, הדורשת איטרציה על כל האלמנטים וחישוב הסכום.",
        "מצב: ברצונך לייצג מבנה נתונים של עץ, כאשר כל צומת מייצג נושא וכל ענף מייצג נושא משנה.  הסבר: מבנה נתונים מסוג עץ יהיה מתאים יותר לייצוג מערכת יחסים היררכית כמו עץ נושאים.",
        "מצב: ברצונך ליצור תור המתמודד עם בקשות של לקוחות, כאשר הלקוח הראשון שמגיע הוא גם הראשון שמתקבל.  הסבר: תור הוא מבנה נתונים מיוחד שמתאים לניהול תורים, והוא יכול להיות מיושם באמצעות רשימה מקושרת או מערך מעגלי."
      ],
      "correctAnswer": 1,
      "explain": "מערכים מתאימים במיוחד למצבים בהם:\n\nגודל המבנה ידוע מראש.\nנדרשת גישה מהירה לאלמנטים לפי האינדקס שלהם.\nאין צורך בהוספות ומחיקות תכופות באמצע המבנה.\nבמקרים אחרים, מבני נתונים אחרים כמו רשימות מקושרות, עצים או טבלאות גיבוב עשויים להיות מתאימים יותר."
    },
    {
      "question": "תאר מצב שבו רשימה מקושרת תהיה בחירה טובה יותר ממערך.",
      "options": [
        "מצב: ברצונך ליצור רשימת משימות שבה אתה יכול להוסיף ולהסיר משימות באופן שרירותי במהלך היום, ללא צורך לדעת מראש את מספר המשימות המרבי.  הסבר:  גמישות בגודל: רשימה מקושרת מאפשרת הוספה והסרה של אלמנטים בכל מקום ברשימה, ללא צורך בהקצאת מראש של מערך בגודל קבוע. זה מאפשר לך להתחיל עם רשימה ריקה ולהוסיף משימות בהדרגה, ללא הגבלה מראש על מספר המשימות. יעילות בהוספה והסרה באמצע: הוספה והסרה של אלמנטים באמצע רשימה מקושרת הן פעולות יעילות יחסית, שכן דורשות שינוי של מצביעים בלבד, ולא הזזה של כל האלמנטים הבאים אחריו כמו במערך.",
        "מצב: ברצונך ליצור מערך של 100 מספרים שלמים ולמצוא את המספר הגדול ביותר.  הסבר: במערך ניתן לגשת לכל אלמנט ישירות לפי האינדקס שלו, מה שהופך את החיפוש אחר המספר הגדול ביותר לפעולה יעילה.",
        "מצב: ברצונך לייצג טבלת גיבוב, שבה כל כניסה מכילה מפתח וערך.  הסבר: טבלת גיבוב היא מבנה נתונים המיועד לאחסון זוגות מפתח-ערך, וגישה מהירה לאלמנטים על פי המפתח.",
        "מצב: ברצונך ליצור מחסנית (Stack), שבה האלמנט האחרון שנכנס הוא הראשון שיוצא.  הסבר: מחסנית יכולה להיות מיושמת גם באמצעות מערך וגם באמצעות רשימה מקושרת, אך לעיתים קרובות מערך הוא הבחירה המועדפת בשל יעילות הגישה לאלמנט העליון."
      ],
      "correctAnswer": 0,
      "explain": "רשימות מקושרות הן בחירה מצוינת כאשר:\n\nהגודל של המבנה הנתונים אינו ידוע מראש.\nנדרשת גמישות בהוספה והסרה של אלמנטים בכל מקום במבנה.\nאין צורך בגישה ישירה לאלמנטים לפי אינדקס.\nבמקרים אחרים, מבני נתונים אחרים כמו מערכים, טבלאות גיבוב או עצים עשויים להיות מתאימים יותר."
    },
    {
      "question": "כיצד תבחר מבנה נתונים לפתרון בעיה חדשה? אילו גורמים יש לקחת בחשבון?",
      "options": [
        "לבחור את מבנה הנתונים הקל ביותר ליישום.",
        "לבחור את מבנה הנתונים הפופולרי ביותר בשפת התכנות שלך.",
        "כדי לבחור מבנה נתונים מתאים לפתרון בעיה חדשה, יש לשקול את סוג הפעולות הנדרשות: האם תצטרך לבצע בעיקר חיפושים, הוספות, מחיקות או פעולות אחרות, תדירות הפעולות: כמה פעמים תבוצע כל פעולה, סדר הגודל של הנתונים: כמה נתונים צפויים לאחסן, דרישות למרחב הזיכרון: האם יש מגבלות על כמות הזיכרון הזמינה, דרישות לזמן ביצוע: האם יש דרישות לזמן תגובה מהיר לפעולות מסוימות, האם הסדר של הנתונים חשוב: האם יש צורך לשמור על סדר מסוים של הנתונים.",
        "כדי לבחור מבנה נתונים מתאים לפתרון בעיה חדשה, נבדוק מה צריך לעשות ואיזה מחשב ישתמש בביצוע ולפי זה נחליט"
      ],
      "correctAnswer": 2,
      "explain": "בחירת מבנה נתונים מתאים היא שלב קריטי בתהליך פתרון בעיות. על ידי שקלול הגורמים הנ\"כים, ניתן לבחור את המבנה הנתונים שיאפשר פתרון יעיל ויעיל מבחינת זמן ומרחב."
    },
    {
      "question": "כיצד ניתן להשתמש במערך לייצוג תמונה?",
      "options": [
        "מערך יכול לייצג רק תמונות בשחור-לבן.",
        "אין צורך במערך כדי לייצג תמונה, ניתן להשתמש בכל מבנה נתונים אחר.",
        "תמונה יכולה להיוצג רק כמערך חד-ממדי.",
        "תמונה דיגיטלית יכולה להיוצג כמערך דו-ממדי של מספרים. כל מספר במערך מייצג את עוצמת הצבע של פיקסל מסוים בתמונה. למשל, בתמונה בשחור-לבן, כל מספר יכול לייצג גוון אפור בין שחור ללבן. בתמונה צבעונית, כל מספר יכול לייצג עוצמת של ערוץ צבע מסוים (אדום, ירוק, כחול)."
      ],
      "correctAnswer": 3,
      "explain": "מערכים דו-ממדיים הם הבסיס לייצוג תמונות דיגיטליות במחשבים. הבנת הקשר בין תמונות ומערכים היא חיונית בתחומים כמו עיבוד תמונה, גרפיקה ממוחשבת ובינה מלאכותית."
    }
  ]
}