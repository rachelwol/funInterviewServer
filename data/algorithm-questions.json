{
  "questions": [
    {
      "question": "מה ההבדל בין מערך לרשימה מקושרת? מתי תבחר באחד מהם?",
      "options": [
        "מערך הוא מבנה נתונים דינאמי בעוד שרשימה מקושרת היא סטטית.",
        "גישה לאלמנט במערך היא תמיד בזמן קבוע O(1), בעוד שב רשימה מקושרת זה תלוי במיקום האלמנט.",
        "רשימות מקושרות טובות יותר להוספה והסרה של אלמנטים באמצע הרשימה, בעוד שמערכים טובים יותר לגישה לאלמנטים לפי האינדקס שלהם.",
        "מערכים תופסים מקום רצוף בזיכרון, בעוד שרשימות מקושרות מפוזרות בזיכרון."
      ],
      "correctAnswer": 2,
      "explain": "ג' נכונה: רשימות מקושרות מעולות להוספה והסרה של אלמנטים באמצע הרשימה, מכיוון שאתה רק צריך לשנות כמה מצביעים. במערך, לעומת זאת, כדי להוסיף אלמנט באמצע, אתה צריך להזיז את כל האלמנטים הבאים, מה שמייקר את הפעולה. גישה לאלמנט במערך לפי האינדקס היא מהירה מאוד (O(1)), בעוד שב רשימה מקושרת, אתה צריך לעבור על כל האלמנטים עד שתגיע למבוקש (במקרה הגרוע ביותר O(n))."
    },
    {
      "question": "הסבר את מושג הסיבוכיות של אלגוריתם. מהם הסימונים הנפוצים לסיבוכיות (O)?",
      "options": [
        "סיבוכיות אלגוריתם מתארת את כמות הזיכרון הנדרשת לאלגוריתם לפעול.",
        "סימון O מייצג את הסיבוכיות הגרועה ביותר של אלגוריתם, כלומר את הזמן המקסימלי שייקח לאלגוריתם לסיים עבור כל קלט בגודל נתון.",
        "סיבוכיות זמן לינארית O(n) פירושה שהזמן לביצוע האלגוריתם גדל באופן פרופורציוני לגודל הקלט.",
        "סיבוכיות קבועה O(1) פירושה שהזמן לביצוע האלגוריתם אינו תלוי בגודל הקלט."
      ],
      "correctAnswer": 1,
      "explain": "ב' נכונה: סימון O אכן מייצג את הסיבוכיות האסימפטוטית הגרועה ביותר של אלגוריתם. זה אומר שבמקרה הגרוע ביותר, הזמן שייקח לאלגוריתם לסיים יהיה פורפורציונאלי לפונקציה של גודל הקלט, כפי שמתואר בסימון O."
    },
    {
      "question": "מהי מחסנית (Stack)? תן דוגמה לשימוש בה בתוכנית.",
      "options": [
        "מחסנית היא מבנה נתונים לינארי שבו הוספה והוצאה מתבצעות רק מהקצה העליון, ועובדת לפי עקרון ''ראשון נכנס, אחרון יוצא'' (LIFO).",
        "מחסנית משמשת בעיקר לייצוג עצי חיפוש בינאריים.",
        "דוגמה לשימוש במחסנית היא במימוש פונקציית רקורסיה, שם המחסנית משמשת לאחסון כתובות החזרה.",
        "מחסנית היא מבנה נתונים דינמי שגודלו קבוע ואינו יכול להשתנות."
      ],
      "correctAnswer": 0,
      "explain": "א' נכונה: זה ההגדרה המדויקת של מחסנית. היא עובדת כמו ערימה של צלחות, כאשר אתה יכול להוסיף או להוציא רק את הצלחת העליונה."
    },
    {
      "question": "מהי תור (Queue)? תן דוגמה לשימוש בה בתוכנית.",
      "options": [
        "תור הוא מבנה נתונים לינארי שבו הוספה מתבצעת מהקצה האחורי והוצאה מתבצעת מהקצה הקדמי, ועובד לפי עקרון ''ראשון נכנס, ראשון יוצא'' (FIFO).",
        "תור משמש בעיקר לייצוג עצי חיפוש בינאריים.",
        "דוגמה לשימוש בתור היא במימוש פונקציית רקורסיה, שם התור משמש לאחסון כתובות החזרה.",
        "תור הוא מבנה נתונים סטטי שגודלו קבוע ואינו יכול להשתנות."
      ],
      "correctAnswer": 0,
      "explain": "א' נכונה: זה ההגדרה המדויקת של תור. בדומה לתור בקופה בסופר, הפריט הראשון שנכנס לתור הוא גם הראשון שיוצא."
    },
    {
      "question": "מהו עץ בינארי חיפוש (Binary Search Tree)? מה המאפיינים שלו?",
      "options": [
        "עץ בינארי חיפוש הוא עץ בינארי שבו ערך כל צומת גדול מכל הערכים בתת-העץ השמאלי שלו וקטן מכל הערכים בתת-העץ הימני שלו.",
        "עץ בינארי חיפוש תמיד מאוזן, כלומר עומק כל הענפים זהה.",
        "חיפוש אלמנט בעץ בינארי חיפוש תמיד לוקח זמן קבוע O(1).",
        "עץ בינארי חיפוש הוא מבנה נתונים דינמי, כלומר ניתן להוסיף ולמחוק ממנו אלמנטים."
      ],
      "correctAnswer": 0,
      "explain": "א' נכונה: זה ההגדרה המדויקת של עץ בינארי חיפוש. תכונה זו מאפשרת חיפוש יעיל מאוד של אלמנטים בעץ."
    },
    {
      "question": "מה ההבדל העיקרי בין אלגוריתם מיון בועות (Bubble Sort) לאלגוריתם מיון מהיר (Quick Sort), ואיזה מהם עדיף בדרך כלל?",
      "options": [
        "מיון בועות יעיל יותר ממיון מהיר בכל המקרים, במיוחד במערכים גדולים. ",
        "מיון מהיר הוא תמיד יציב, כלומר שומר על הסדר היחסי של אלמנטים שווים, בעוד שמיון בועות אינו יציב. ",
        "מיון בועות מבוסס על השוואות חוזרות ונשנות בין זוגות אלמנטים סמוכים, בעוד שמיון מהיר משתמש בשיטה של חלוקה וכבוש כדי לחלק את המערך לחלקים קטנים יותר ולמיין אותם בנפרד.",
        "שני האלגוריתמים דומים בסיבוכיות שלהם, אך מיון בועות קל יותר למימוש."
      ],
      "correctAnswer": 2,
      "explain": "ג' נכונה: מיון בועות מבוסס על השוואות חוזרות ונשנות בין זוגות אלמנטים סמוכים, בעוד שמיון מהיר משתמש בשיטה של חלוקה וכבוש כדי לחלק את המערך לחלקים קטנים יותר ולמיין אותם בנפרד."
    },
    {
      "question": "מהי טבלת גיבוב (Hash Table)? כיצד היא פועלת? מהי התנגשות (Collision) ואיך מטפלים בה?",
      "options": [
        "טבלת גיבוב היא מבנה נתונים המאפשר גישה מהירה מאוד לכל אלמנט, אך היא סובלת מהתנגשויות רבות שאי אפשר לפתור.",
        "טבלת גיבוב פועלת על ידי שימוש בפונקציית גיבוב אשר ממירה את המפתח של כל אלמנט למספר שלם, המייצג את האינדקס של האלמנט במערך. התנגשות מתרחשת כאשר שני מפתחות שונים מתמפים לאותו אינדקס.",
        "טבלת גיבוב היא מבנה נתונים מסודר, שבו האלמנטים מסודרים לפי סדר עולה של המפתחות שלהם.",
        "התנגשות מטופלת על ידי הגדלת גודל הטבלה בכל פעם שמתרחשת התנגשות."
      ],
      "correctAnswer": 1,
      "explain": "תשובה ב' היא הנכונה מכיוון שהיא מתארת בצורה מדויקת את עקרון הפעולה של טבלת גיבוב, כולל השימוש בפונקציית גיבוב, התנגשויות ויעילות."
    },
    {
      "question": "מהו גרף? מה ההבדל בין גרף מכוון ללא מכוון? תן דוגמה לשימוש בגרף בבעיה מהעולם האמיתי.",
      "options": [
        "גרף הוא מבנה נתונים המייצג קשרים בין ישויות. גרף מכוון מייצג קשר חד-כיווני בין ישויות, בעוד גרף לא מכוון מייצג קשר דו-כיווני. דוגמה: רשת חברתית, שבה כל משתמש הוא צומת והקשרים ביניהם הם קשתות מכוונות (עוקב/נעקב אחריה).",
        "גרף הוא תרשים המציג נתונים מספריים בצורה ויזואלית. גרף מכוון הוא גרף שבו הקשתות מצביעות על כיוון הזרימה, בעוד גרף לא מכוון הוא גרף שבו הקשתות אינן מכוונות. דוגמה: מפת דרכים, שבה כל צומת מייצג צומת דרכים והקשתות מייצגות כבישים חד-כיווניים.",
        "גרף הוא מבנה נתונים המשמש לאחסון מידע מספרי. גרף מכוון הוא גרף שבו הקשתות מחוברות רק לצמתים מסוג מסוים, בעוד גרף לא מכוון הוא גרף שבו הקשתות יכולות לחבר כל שני צמתים. דוגמה: עץ משפחה, שבה כל אדם הוא צומת והקשרים ביניהם הם קשתות מכוונות (הורה/ילד).",
        "גרף הוא מבנה נתונים המייצג רשת של קשרים. גרף מכוון הוא גרף שבו הקשתות יכולות להיות במשקלים שונים, בעוד גרף לא מכוון הוא גרף שבו כל הקשתות בעלות אותו משקל. דוגמה: רשת האינטרנט, שבה כל אתר הוא צומת והקשרים ביניהם הם קשתות המייצגות קישורים היפר-טקסטואליים. "
      ],
      "correctAnswer": 0,
      "explain": "תשובה א' היא הנכונה מכיוון שהיא מספקת הגדרה מדויקת ומקיפה של גרף, מבדילה בצורה ברורה בין סוגי גרפים ומציעה דוגמה רלוונטית."
    },
    {
      "question": "מהו אלגוריתם דינמי? מתי משתמשים בו? תן דוגמה.",
      "options": [
        "אלגוריתם דינמי הוא שיטה לפתרון בעיות על ידי פירוקן לבעיות משנה קטנות יותר ופתרון כל בעיית משנה פעם אחת בלבד, תוך שמירה של התוצאות כדי למנוע חישובים חוזרים. משתמשים בו בבעיות אופטימיזציה שבהן יש חפיפה בין תת-הבעיות. דוגמה: חישוב המסלול הקצר ביותר בין שני צמתים בגרף.",
        "אלגוריתם דינמי הוא אלגוריתם רקורסיבי שמבוסס על חלוקה של הבעיה לחלקים קטנים יותר. משתמשים בו בבעיות ספירה, כמו למשל חישוב מספר האפשרויות לבחור k כדורים מתוך n כדורים שונים.",
        "אלגוריתם דינמי הוא אלגוריתם יעיל במיוחד לפתרון בעיות סידור, כמו מיון מערך. משתמשים בו כאשר הסדר של הפעולות אינו חשוב.",
        "אלגוריתם דינמי הוא אלגוריתם שמשתמש בטבלה כדי לשמור את התוצאות של חישובים קודמים. משתמשים בו רק בבעיות שבהן יש צורך לחשב את כל הפתרונות האפשריים."
      ],
      "correctAnswer": 0,
      "explain": "תשובה 1 היא הנכונה מכיוון שהיא מספקת הגדרה מדויקת ומקיפה של אלגוריתם דינמי, מציינת את היישומים העיקריים שלו ומספקת דוגמה רלוונטית."
    },
    {
      "question": "הסבר את מושג העץ האדום-שחור. מה המאפיינים שלו?",
      "options": [
        "עץ אדום-שחור הוא גרף מכוון שבו הקשתות מסומנות באדום או בשחור. הוא משמש לייצוג מערכות מדיניות, כאשר הצבעים מייצגים רמות שונות של חשיבות. מאפיינים עיקריים: כל צומת יכול להיות מחובר לכל צומת אחר, והצבע של הקשת קובע את סוג הקשר.",
        "עץ אדום-שחור הוא מבנה נתונים דינמי המשמש לאחסון מידע מספרי. הוא מבוסס על סידור של מספרים לפי גודלם, כאשר הצבעים מייצגים את הזוגיות של המספר. מאפיינים עיקריים: כל צומת מכיל מספר, והצבע שלו קובע אם המספר זוגי או אי-זוגי. ",
        "עץ אדום-שחור הוא מבנה נתונים סטטי המשמש לייצוג היררכיות. הוא דומה לעץ משפחה, כאשר הצבעים מייצגים את המין של האדם. מאפיינים עיקריים: השורש מייצג את האב הקדמון, והעלים מייצגים את הדורות הצעירים.",
        "עץ אדום-שחור הוא מבנה נתונים מסוג עץ חיפוש בינארי מאוזן בקירוב. כל צומת בעץ מסומן כאדום או שחור, כאשר ישנם כללים קפדניים לגבי מיקום הצמתים האדומים והשחורים. מאפיינים עיקריים: כל עלה הוא שחור, כל צומת אדום חייב להיות בעל שני בנים שחורים, וכל מסלול מהשורש לכל עלה מכיל את אותו מספר של צמתים שחורים."
      ],
      "correctAnswer": 3,
      "explain": "תשובה ד' היא הנכונה מכיוון שהיא מספקת הגדרה מדויקת ומקיפה של עץ אדום-שחור, ומציינת את המאפיינים החשובים ביותר שלו."
    },
    {
      "question": "באיזה מבנה נתונים היית משתמש לייצוג רשת חברתית? נמק את בחירתך.",
      "options": [
        "מערך דו-ממדי: מערך דו-ממדי יכול לשמש לייצוג רשת חברתית קטנה ופשוטה, אך הוא אינו יעיל עבור רשתות גדולות ומורכבות. מערך דו-ממדי אינו גמיש מספיק כדי לייצג קשרים מורכבים בין משתמשים.",
        "גרף: גרף הוא הבחירה הטבעית ביותר לייצוג רשת חברתית. כל משתמש ברשת הוא צומת בגרף, והקשרים ביניהם (חברות, עוקב/נעקב) מיוצגים על ידי קשתות. גרף מאפשר לנו לבצע מגוון רחב של ניתוחים על הרשת, כמו מציאת חברים משותפים, חישוב המרחק החברתי בין משתמשים, וגילוי קהילות.",
        "עץ חיפוש בינארי: עץ חיפוש בינארי מתאים לאחסון מידע מסודר, אך אינו מתאים לייצוג רשתות חברתיות. ברשת חברתית, לכל משתמש יכול להיות מספר שרירותי של חברים, מה שאינו מתאים למבנה ההיררכי של עץ חיפוש בינארי.",
        "רשימה מקושרת: רשימה מקושרת יכולה לשמש לייצוג רשת חברתית, אך היא אינה יעילה לחיפוש ולעדכון. מציאת חבר מסוים ברשימה מקושרת דורשת סריקה סדרתית של כל הרשימה."
      ],
      "correctAnswer": 1,
      "explain": "ב' נכונה: גרף הוא הבחירה הטובה ביותר לייצוג רשת חברתית מכיוון שהוא מתאים באופן מושלם למבנה של רשתות, הוא גמיש וניתן לניתוח."
    },
    {
      "question": "תאר אלגוריתם יעיל למציאת המספר החסר במערך של מספרים שלמים מ-1 עד n, כאשר רק מספר אחד חסר.",
      "options": [
        "חישוב סכום: נחשב את סכום כל המספרים מ-1 עד n (n*(n+1)/2). לאחר מכן, נחשב את סכום המספרים במערך. ההפרש בין שני הסכומים יהיה המספר החסר. אלגוריתם זה יעיל מאוד מבחינת סיבוכיות זמן (O(n)).",
        "מיון: נמיין את המערך בסדר עולה. נעבור על המערך מסודר ונשווה כל איבר למדד שלו במערך. האיבר הראשון שבו לא מתקיים השוויון מצביע על המספר החסר. סיבוכיות זמן תלויה באלגוריתם המיון שנבחר (למשל, מיון מהיר: O(n log n)). ",
        "שימוש במערך עזר: נבנה מערך עזר באורך n, ונתחיל את כל האיברים ב-0. נעבור על המערך המקורי, ובכל איטרציה נסמן 1 במערך העזר במקום המתאים למספר הנוכחי. בסוף, האינדקס שבו נשאר 0 במערך העזר מצביע על המספר החסר. סיבוכיות זמן היא O(n), אך דורשת שימוש במערך עזר נוסף.",
        "חיפוש בינארי: נבצע חיפוש בינארי במערך כדי למצוא את המספר החסר. אלגוריתם זה יעיל רק אם המערך ממויין. מכיוון שהמערך אינו בהכרח ממויין, חיפוש בינארי אינו מתאים לבעיה זו"
      ],
      "correctAnswer": 0,
      "explain": "א' נכונה: החישוב הישיר של סכום המספרים הוא השיטה היעילה והפשוטה ביותר למציאת המספר החסר במערך."
    },
    {
      "question": "הסבר את החשיבות של בחירת מבנה נתונים מתאים לפתרון בעיה מסוימת.",
      "options": [
        "מבנה הנתונים אינו חשוב כל כך, העיקר שהאלגוריתם יהיה נכון. כל מבנה נתונים יכול לשמש לפתרון כל בעיה, רק שהאלגוריתם יהיה מורכב יותר. לדוגמה, ניתן להשתמש ברשימה מקושרת כדי לייצג מערך, אך זה יאט את ביצועי האלגוריתם.",
        "מבנה הנתונים אינו חשוב כל כך, העיקר שהאלגוריתם יהיה נכון. כל מבנה נתונים יכול לשמש לפתרון כל בעיה, רק שהאלגוריתם יהיה מורכב יותר. לדוגמה, ניתן להשתמש ברשימה מקושרת כדי לייצג מערך, אך זה יאט את ביצועי האלגוריתם.",
        "מבנה הנתונים צריך להתאים לשפת התכנות בה משתמשים. כל שפת תכנות תומכת במבני נתונים שונים, ולכן יש לבחור את המבנה המתאים לשפה.",
        "בחירת מבנה נתונים מתאים היא קריטית ליעילות האלגוריתם. מבנה נתונים שמתאים לבעיה מאפשר גישה מהירה לנתונים, ביצוע פעולות בצורה יעילה יותר, וחיסכון בזמן ובמקום בזיכרון. לדוגמה, אם נרצה למצוא את האיבר הקטן ביותר במערך, מערך מסודר יהיה יעיל יותר מאשר מערך לא מסודר."
      ],
      "correctAnswer": 3,
      "explain": "ד' נכונה: בחירת מבנה נתונים מתאים היא שלב קריטי בתכנון אלגוריתם. מבנה נתונים טוב יכול לשפר משמעותית את יעילות האלגוריתם, להפחית את סיבוכיותו ולשפר את קריאות הקוד."
    },
    {
      "question": "מהו מבנה הנתונים המתאים ביותר לייצוג מילון (dictionary) בשפה כמו פייתון?",
      "options": [
        "מערך",
        "רשימה מקושרת",
        "עץ חיפוש בינארי",
        "טבלת גיבוב (Hash Table)"
      ],
      "correctAnswer": 3,
      "explain": "ד' נכונה: טבלת גיבוב היא מבנה הנתונים האידיאלי לייצוג מילון בשפות כמו פייתון. הסיבה לכך היא שהיא מאפשרת גישה מהירה מאוד לערכים על ידי שימוש במפתחות."
    }
  ]
}